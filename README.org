* What is it?
=haskell-emacs= is a library which allows extending emacs in haskell.
It provides an FFI (foreign function interface) for haskell functions.

* Examples
Consider that you've got the following toy program:

#+BEGIN_SRC haskell
-- /home/foo/.emacs.d/haskell-fun/Matrix.hs
module Matrix (identity,isIdentity,dyadic,transpose) where

import qualified Data.List as L

transpose :: [[Int]] -> [[Int]]
transpose = L.transpose

identity :: Int -> [[Int]]
identity n
  | n > 1 = L.nub $ L.permutations $ 1 : replicate (n-1) 0
  | otherwise = [[1]]

isIdentity :: [[Int]] -> Bool
isIdentity xs = xs == identity (length xs)

dyadic :: [Int] -> [Int] -> [[Int]]
dyadic xs ys = map (\x -> map (x*) ys) xs
#+END_SRC

Add the directory of =haskell-emacs= to your emacs load path:
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/git/haskell-emacs/")
#+END_SRC

Start your emacs and evaluate following expression (and put it in
your .emacs if you like):
#+BEGIN_SRC emacs-lisp
(require 'haskell-emacs)
(haskell-emacs-init)
#+END_SRC
Note that it is not sufficient to evaluate the buffer of the source
file, it has to know where some haskell glue code is located and uses
therefore =load-file-name=, so you have to load or require it, and the
glue code must be in the same directory (which is the case if you
simply clone the repo).

Now you're set to toy around with your new elisp functions:
#+BEGIN_SRC emacs-lisp
(Matrix.identity 3)
  => ((1 0 0) (0 1 0) (0 0 1))

(Matrix.transpose '((1 2) (3 4) (5 6)))
  => ((1 3 5) (2 4 6))

(Matrix.isIdentity '((1 0) (0 1)))
  => t

(Matrix.dyadic '(1 2 3) '(4 5 6))
  => ((4 5 6) (8 10 12) (12 15 18))
#+END_SRC

Now consider some bad input:
#+BEGIN_SRC emacs-lisp
(Matrix.identity "a")
  => Debugger entered--Lisp error: (error "when expecting a Integral, encountered string instead")

(Matrix.transpose [(1 2) [3 4]])
  => ((1 3) (2 4))

(Matrix.dyadic '+)
  => Debugger entered--Lisp error: (error "when expecting a pair, encountered symbol instead")
#+END_SRC

You see that type errors get errors in emacs with good descriptions of
the error.  It puts only an error, if the parser doesn't find a
transformation of your proposed input to the required type of the
haskell function.  Arrays will be translated (recursively) to Lists,
and Lists can represent Lists or Tuples.

* Performance
There is a (very) small overhead calling haskell functions, so for very
trivial situations, elisp functions will be faster.  On my laptop
(i5-4210, 2.7Ghz) it costs the following:
- 0.07 ms per function call
- 0.0005 ms per received char
- 0.0004 ms per sended char

Unless you use haskell functions on megabytes of text or in very tight
loops (which wouldn't be wise, transfer the whole task to haskell) the
overhead is irrelevant.

* Dependencies
You'll need:
- ghc
- attoparsec
- atto-lisp
- show-text

Thats all.

* Shortcomings
About 10 types are recognized as input, and about 10 types of output
can be transformed into an elisp type.  Thats quite good, but not
everything.  If you write a function with an unknown type,
=haskell-emacs-init= will signal an error with the output from ghc.

Polymorphic types are not well supported and higher functions aren't
supported at all, you can't pass functions as arguments to haskell
functions in emacs.

If a haskell function crashes haskell-emacs a error will be thrown and
the server process will be restarted immediately.  In this process,
every async call will be obviously lost.
* Future plans
For performance and modularity reasons, I plan to turn curried haskell
elisp functions into macros, which check whether it's argument is a
haskell function.  With this knowledge, function calls can be fused
and a succesion of for example 5 functions will be executed entirely
on the haskell side, without the need, to receive and send back every
result.  This would as well allow to run asynchronously a chained
function call, which gives a lot of new oppertunities.

* What is it?
=haskell-emacs= is a library which allows extending emacs in haskell.
It provides an FFI (foreign function interface) for haskell functions.

* Examples
Consider that you've got the following toy program:

#+BEGIN_SRC haskell
-- /home/foo/.emacs.d/haskell-fun/Matrix.hs
module Matrix (identity,isIdentity,dyadic,transpose) where

import qualified Data.List as L

transpose :: [[Int]] -> [[Int]]
transpose = L.transpose

identity :: Int -> [[Int]]
identity n
  | n > 1 = L.nub $ L.permutations $ 1 : replicate (n-1) 0
  | otherwise = [[1]]

isIdentity :: [[Int]] -> Bool
isIdentity xs = xs == identity (length xs)

dyadic :: ([Int],[Int]) -> [[Int]]
dyadic (xs,ys) = map (\x -> map (x*) ys) xs
#+END_SRC

Start your emacs and evaluate following expression (and put it in
your .emacs if you like):
#+BEGIN_SRC emacs-lisp
(require 'haskell-emacs)
(haskell-emacs-init)
#+END_SRC

Now you're set to toy around with your new elisp functions:
#+BEGIN_SRC emacs-lisp
(Matrix.identity 3)
  => ((1 0 0) (0 1 0) (0 0 1))

(Matrix.transpose '((1 2) (3 4) (5 6)))
  => ((1 3 5) (2 4 6))

(Matrix.isIdentity '((1 0) (0 1)))
  => t

(Matrix.dyadic '((1 2 3) (4 5 6)))
  => ((4 5 6) (8 10 12) (12 15 18))
#+END_SRC

Now consider some bad input:
#+BEGIN_SRC emacs-lisp
(Matrix.identity "a")
  => Debugger entered--Lisp error: (error "when expecting a Integral, encountered string instead")

(Matrix.transpose [(1 2) [3 4]])
  => ((1 3) (2 4))

(Matrix.dyadic '+)
  => Debugger entered--Lisp error: (error "when expecting a pair, encountered symbol instead")
#+END_SRC

You see that type errors get errors in emacs with good descriptions of
the error.  It puts only an error, if the parser doesn't find a
transformation of your proposed input to the required type of the
haskell function.  Arrays will be translated (recursively) to Lists,
and Lists can represent Lists or Tuples.

* Performance
There is a small overhead calling haskell functions, so for very
trivial situations, elisp functions will be faster.  On my laptop
(i5-4210, 2.7Ghz) it costs the following:
- 0.4 ms per function call
- 0.003 ms per received char
- 0.0005 ms per sended char

Unless you use haskell functions on megabytes of text or in very tight
loops the overhead is irrelevant.

* Dependencies
You'll need:
- ghc
- attoparsec
- atto-lisp

Thats all.

* Shortcomings
About 10 types are recognized as input, and about 10 types of output
can be transformed into an elisp type.  Thats quite good, but not
everything.  If you write a function with an unknown type,
=haskell-emacs-init= will signal an error with the output from ghc.

At the moment, only curried functions can be used, other types cause
errors (again on run of =haskell-emacs-init=, so you'll notice
immediately).

Polymorphic types are not well supported and higher functions aren't
supported at all, you can't pass functions as arguments to haskell
functions in emacs.

If a haskell function causes an error, you have to rerun =haskell-emacs-init=.
